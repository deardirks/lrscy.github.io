<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meow</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lrscy.github.io/"/>
  <updated>2019-01-27T20:50:42.539Z</updated>
  <id>https://lrscy.github.io/</id>
  
  <author>
    <name>Meow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 984 String Without AAA or BBB</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-984-String-Without-AAA-or-BBB/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-984-String-Without-AAA-or-BBB/</id>
    <published>2019-01-27T20:18:19.000Z</published>
    <updated>2019-01-27T20:50:42.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>The solution of <a href="https://leetcode.com/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">problem 984</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/984-String%20Without%20AAA%20or%20BBB.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string strWithout3a3b(int A, int B) &#123;</span><br><span class="line">        string s = &quot;&quot;;</span><br><span class="line">        int a = 0, b = 0;</span><br><span class="line">        while( A || B ) &#123;</span><br><span class="line">            int ta = 0, tb = 0;</span><br><span class="line">            while( ta &lt; 2 &amp;&amp; B &lt;= 2 * A &amp;&amp; A &gt; 0 ) &#123; s += &quot;a&quot;; ++ta; --A; &#125;</span><br><span class="line">            while( tb &lt; 2 &amp;&amp; A &lt;= 2 * B &amp;&amp; B &gt; 0 ) &#123; s += &quot;b&quot;; ++tb; --B; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The core method of the problem is to make sure that the number of each character is no less than half of another character and no exceed two consecutively.</p><h1 id="Valuable-Method"><a href="#Valuable-Method" class="headerlink" title="Valuable Method"></a>Valuable Method</h1><p>I’ve tried to find pattern at first time, such as “aab”, “abb”, and etc. Finally, I find that if we want to prevent those “aaa” and “bbb” appear, we just need to keep the ratio of number of two characters. It’s easier to apply a simple rule rather than setting many patterns and it looks clean and beautiful.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;The solution of &lt;a href=&quot;https://leetcode.com/problems/string-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 982 Triples with Bitwise AND Equal To Zero</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-982-Triples-with-Bitwise-AND-Equal-To-Zero/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-982-Triples-with-Bitwise-AND-Equal-To-Zero/</id>
    <published>2019-01-27T19:19:55.000Z</published>
    <updated>2019-01-27T20:16:29.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>The solution of <a href="https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/" target="_blank" rel="noopener">problem 982</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/982-Triples%20with%20Bitwise%20AND%20Equal%20To%20Zero.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countTriplets(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int n = A.size();</span><br><span class="line">        int inv[1 &lt;&lt; 16] = &#123; 0 &#125;;</span><br><span class="line">        for( auto a : A ) &#123;</span><br><span class="line">            for( int i = 0; i &lt; ( 1 &lt;&lt; 16 ); ++i )</span><br><span class="line">                if( ( a &amp; i ) == 0 )</span><br><span class="line">                    ++inv[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for( int i = 0; i &lt; n; ++i ) &#123;</span><br><span class="line">            for( int j = 0; j &lt; n; ++j ) &#123;</span><br><span class="line">                ret += inv[A[i] &amp; A[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The core method to solve it is to treat one number previously and traverse all combination of two numbers $a \&amp; b$ in the vector. In this way, we can reduce the time complexity from $O(N^3)$ to $O(N^2)$. The treatment is to pre-calculate each number $a$ in the vector to find with which number $b$ $a \&amp; b$ would get $0$.</p><h1 id="Valuable-Method"><a href="#Valuable-Method" class="headerlink" title="Valuable Method"></a>Valuable Method</h1><p>The pre-treating method is really important when solving problems. If we enumerate all three numbers combination, for example $a \&amp; b \&amp; c$, we would repeatly calculate &amp; operator with $c$ for many times. By remembering it, we could use more space to reduce run time. Moreoever, we could also store the result of $a \&amp; b$ and check the result by $c$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;The solution of &lt;a href=&quot;https://leetcode.com/problems/triples
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 843 Guess the Word</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-843-Guess-the-Word/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-843-Guess-the-Word/</id>
    <published>2019-01-27T18:54:15.000Z</published>
    <updated>2019-01-27T19:47:44.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>The solution of <a href="https://leetcode.com/problems/guess-the-word/" target="_blank" rel="noopener">problem 843</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/843-Guess%20the%20Word.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the Master&apos;s API interface.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * class Master &#123;</span><br><span class="line"> *   public:</span><br><span class="line"> *     int guess(string word);</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">auto desyncio = []()</span><br><span class="line">&#123;</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void findSecretWord(vector&lt;string&gt;&amp; wordlist, Master&amp; master) &#123;</span><br><span class="line">        long long prob[10][30] = &#123; 0 &#125;;</span><br><span class="line">        for( auto &amp;w : wordlist ) &#123;</span><br><span class="line">            for( int i = 0; i &lt; 6; ++i ) prob[i][w[i] - &apos;a&apos;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        while( true ) &#123;</span><br><span class="line">            string tmp = generate( prob, wordlist );</span><br><span class="line">            int ret = master.guess( tmp );</span><br><span class="line">            if( ret == tmp.length() ) break;</span><br><span class="line">            for( auto it = wordlist.begin(); it != wordlist.end(); ) &#123;</span><br><span class="line">                if( match( *it, tmp ) != ret ) &#123;</span><br><span class="line">                    for( int i = 0; i &lt; 6; ++i )</span><br><span class="line">                        prob[i][( *it )[i] - &apos;a&apos;] -= 1;</span><br><span class="line">                    wordlist.erase( it );</span><br><span class="line">                &#125; else ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string generate( long long prob[][30], vector&lt;string&gt;&amp; wordlist ) &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        long long best = 0;</span><br><span class="line">        for( auto w : wordlist ) &#123;</span><br><span class="line">            long long tpscore = 1;</span><br><span class="line">            for( int i = 0; i &lt; 6; ++i ) tpscore *= prob[i][w[i] - &apos;a&apos;];</span><br><span class="line">            if( tpscore &gt; best ) &#123;</span><br><span class="line">                best = tpscore;</span><br><span class="line">                ret = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int match( string a, string b ) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for( int i = 0; i &lt; a.length(); ++i ) &#123;</span><br><span class="line">            if( a[i] == b[i] ) ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The thought of the problem is from a <a href="https://leetcode.com/problems/guess-the-word/discuss/134087/C%2B%2B-elimination-histogram-beats-Minimax" target="_blank" rel="noopener">discussion</a> of the problem. Basically, we count all characters on each position from 1 to 6 as there probability. Then we generate a string with highest probability and guess it. Based on what return to us, we eliminate all other candidates which does not meet the requirement. Finally, we will guess the right word.</p><h1 id="Interesting-Point"><a href="#Interesting-Point" class="headerlink" title="Interesting Point"></a>Interesting Point</h1><p>It’s a whole new kind of problem. The method to solve it is now fixed. Statistic is a candidate method to this problem. This kind of problem is just so fun and interesting!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;The solution of &lt;a href=&quot;https://leetcode.com/problems/guess-t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 200 Number of Islands</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-200-Number-of-Islands/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-200-Number-of-Islands/</id>
    <published>2019-01-27T18:24:09.000Z</published>
    <updated>2019-01-27T18:46:14.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>The solution of <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">problem 200</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/200-Number%20of%20Islands.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">auto desyncio = []()</span><br><span class="line">&#123;</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int dx[4] = &#123; 1, 0, -1, 0 &#125;, dy[4] = &#123; 0, 1, 0, -1 &#125;;</span><br><span class="line">    int nx, ny;</span><br><span class="line">    </span><br><span class="line">    void bfs( vector&lt;vector&lt;char&gt;&gt;&amp; grid, int x, int y ) &#123;</span><br><span class="line">        queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">        q.push( make_pair( x, y ) );</span><br><span class="line">        grid[x][y] = &apos;0&apos;;</span><br><span class="line">        while( !q.empty() ) &#123;</span><br><span class="line">            auto tmp = q.front(); q.pop();</span><br><span class="line">            for( int i = 0; i &lt; 4; ++i ) &#123;</span><br><span class="line">                int tx = tmp.first + dx[i], ty = tmp.second + dy[i];</span><br><span class="line">                if( tx &lt; 0 || tx &gt;= nx || ty &lt; 0 || ty &gt;= ny ) continue;</span><br><span class="line">                if( grid[tx][ty] == &apos;1&apos; ) &#123;</span><br><span class="line">                    grid[tx][ty] = &apos;0&apos;;</span><br><span class="line">                    q.push( make_pair( tx, ty ) );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        nx = grid.size();</span><br><span class="line">        if( nx ) ny = grid[0].size();</span><br><span class="line">        for( int i = 0; i &lt; nx; ++i ) &#123;</span><br><span class="line">            for( int j = 0; j &lt; ny; ++j ) &#123;</span><br><span class="line">                if( grid[i][j] == &apos;1&apos; ) &#123;</span><br><span class="line">                    ++ret;</span><br><span class="line">                    bfs( grid, i, j );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The solution of the problem is simply <strong>BFS/DFS</strong>. Check on each position and go BFS/DFS search when the position is “1”.</p><h1 id="Valueable-Method"><a href="#Valueable-Method" class="headerlink" title="Valueable Method"></a>Valueable Method</h1><p>I choose the BFS and here is a trick. If you choose to change status after retreat from queue, you will push a huge amount of duplicate position into queue which will cause <strong>“Memory Limit Exceed”</strong> and slow down your program. So If treating each action before pushing into queue, it would save huge amount of memory and run faster.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;The solution of &lt;a href=&quot;https://leetcode.com/problems/number-
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 159 Longest Substring with At Most Two Distinct Characters</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters/</id>
    <published>2019-01-27T16:47:14.000Z</published>
    <updated>2019-01-27T18:48:05.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>The solution of <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">problem 159</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/159-Longest%20Substring%20with%20At%20Most%20Two%20Distinct%20Characters.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">        int ret = 0, len = s.length();</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; mp;</span><br><span class="line">        if( s.size() &lt;= 2 ) return s.size();</span><br><span class="line">        while( j &lt; len ) &#123;</span><br><span class="line">            mp[s[j]] = j;</span><br><span class="line">            if( mp.size() &gt; 2 ) &#123;</span><br><span class="line">                ret = max( ret, j - i );</span><br><span class="line">                while( mp.size() &gt; 2 ) &#123;</span><br><span class="line">                    int key, n = INT_MAX;</span><br><span class="line">                    for( auto it = mp.begin(); it != mp.end(); ++it ) &#123;</span><br><span class="line">                        if( it-&gt;second &lt; n ) &#123;</span><br><span class="line">                            n = it-&gt;second;</span><br><span class="line">                            key = it-&gt;first;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i = n + 1;</span><br><span class="line">                    mp.erase( key );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max( ret, j - i );</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>To solve the problem, you need to build a <strong>map</strong> to store <strong>the last position</strong> of each unique element and use <strong>sliding window</strong> to get the final result.</p><p>The sliding window means that expanding the right side of the window first until exceeding the limit, three unique elements, then querying each element in map and kicking the most left element out. In this way, the window starts sliding until the end of the string.</p><h1 id="Valuable-Method"><a href="#Valuable-Method" class="headerlink" title="Valuable Method"></a>Valuable Method</h1><p>At the first time, I use map to store number of elements in a sliding window rather than their position. It’s OK but stores an useless information–number. Also, my first try will scan the whole string twice which slows down the whole program. However, if we just store the position of each element, we just need to scan the whole string once and also get the right result. It’s also a kind of optimization on constant, which reduces the time complexity from O(2N) to O(N).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;The solution of &lt;a href=&quot;https://leetcode.com/problems/longest
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 146 LRU Cache</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode-146-LRU-Cache/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode-146-LRU-Cache/</id>
    <published>2019-01-27T15:52:23.000Z</published>
    <updated>2019-01-27T18:46:52.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>Solution of <a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">problem 146</a> is showed below. You can also find it <a href="https://github.com/lrscy/LeetCode/blob/master/Algorithm/146-LRU%20Cache.cpp" target="_blank" rel="noopener">here</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static const int _ = []() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if( !mp.count( key ) ) return -1;</span><br><span class="line">        lst.splice( lst.begin(), lst, mp[key] );</span><br><span class="line">        return mp[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if( mp.count( key ) ) &#123;</span><br><span class="line">            mp[key]-&gt;second = value;</span><br><span class="line">            lst.splice( lst.begin(), lst, mp[key] );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            lst.push_front( make_pair( key, value ) );</span><br><span class="line">            mp[key] = lst.begin();</span><br><span class="line">            if( lst.size() &gt; cap ) &#123;</span><br><span class="line">                mp.erase( lst.rbegin()-&gt;first );</span><br><span class="line">                lst.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    int cap;</span><br><span class="line">    unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; mp;</span><br><span class="line">    list&lt;pair&lt;int, int&gt;&gt; lst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>To solve the problem, you need to build a <strong>list</strong> to store the order of “key”-“value” pair and to build a <strong>map</strong> to store “key”-“position in list” pair. Thus, when putting a “key”-“value” pair, you will easily know its position and update the order.</p><h1 id="Valueable-Function"><a href="#Valueable-Function" class="headerlink" title="Valueable Function"></a>Valueable Function</h1><p>The interesting part of this code is the function <strong>“splice”</strong> of list. It can be found on <a href="http://www.cplusplus.com/reference/list/list/splice/" target="_blank" rel="noopener">c++ reference</a>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void splice (iterator position, list&amp; x, iterator i);</span><br></pre></td></tr></table></figure></p><p>The function will transfer element “i” in list “x” to specific “position”. </p><p>Before using this funcition, I wrote a segment of code to implement the function by myself but it runs slower than the function. In this case, by using this function, I transfer the “mp[key]” in list “lst” to the front of the list “lst”.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h1&gt;&lt;p&gt;Solution of &lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot;
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Solution" scheme="https://lrscy.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Solution Summary</title>
    <link href="https://lrscy.github.io/2019/01/27/LeetCode/"/>
    <id>https://lrscy.github.io/2019/01/27/LeetCode/</id>
    <published>2019-01-27T15:05:53.000Z</published>
    <updated>2019-01-27T20:51:10.375Z</updated>
    
    <content type="html"><![CDATA[<p>This blog is a summary of my solution of LeetCode problems. I will share several interesting problems in this blog and category. Most of my solutions are on my <a href="https://github.com/lrscy/LeetCode" target="_blank" rel="noopener">Github</a>.</p><p>Most of my algorithm problem solutions are written in C++ and some of them are written in Python3. Most of my databse problem solutions are written in MySQL.</p><h1 id="Basic-Acceleration"><a href="#Basic-Acceleration" class="headerlink" title="Basic Acceleration"></a>Basic Acceleration</h1><p>Here is a way to reduce runtime when judging online with C++. Here is the code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> desyncio = []() &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span> .tie( <span class="literal">nullptr</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie( <span class="literal">nullptr</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>This code will close the synchronize of two kinds of input and output in C format and C++ format. In C, mostly, we use “scanf”, “printf”, and other similar functions to control the input and output of our program, while in C++, we use “cin”, “cout”, and other funcitons respectively. Since in some case, we would use both of them in our program and they won’t work as what we want without being controlled, C++ use synchronize to manage them. However, this rule will significantly slow down our program, especially when inputing and outputing large scale of data only in C or C++ format. Thus, we can close the synchronize by using codes upward.</p><h1 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h1><p>When solving problems on LeetCode, I found some problems are really interesting, some solutions are so amazing, and some methods are valuable to learn and remember. I will post individual blogs for them and here is the index of them.</p><ul><li><a href="/2019/01/27/LeetCode-146-LRU-Cache">146 LRU Cache</a></li><li><a href="/2019/01/27/LeetCode-159-Longest-Substring-with-At-Most-Two-Distinct-Characters">159 Longest Substring with At Most Two Distinct Characters</a></li><li><a href="/2019/01/27/LeetCode-200-Number-of-Islands">200 Number of Islands</a></li><li><a href="/2019/01/27/LeetCode-843-Guess-the-word">843 Guess the word</a></li><li><a href="/2019/01/27/LeetCode-982-Triples-with-Bitwise-AND-Equal-To-Zero">982 Triples with Bitwise AND Equal To Zero</a></li><li><a href="/2019/01/27/LeetCode-984-String-Without-AAA-or-BBB">984 String Without AAA or BBB</a></li></ul><p>To be uploaded:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This blog is a summary of my solution of LeetCode problems. I will share several interesting problems in this blog and category. Most of 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://lrscy.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lrscy.github.io/tags/LeetCode/"/>
    
      <category term="Summary" scheme="https://lrscy.github.io/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>DeepLearning.ai Note - Neural Network and Deep Learning</title>
    <link href="https://lrscy.github.io/2018/10/22/DeepLearningNotes-NNandDL/"/>
    <id>https://lrscy.github.io/2018/10/22/DeepLearningNotes-NNandDL/</id>
    <published>2018-10-22T16:32:25.000Z</published>
    <updated>2018-11-01T02:45:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>This is a note of the first course of the “Deep Learning Specialization” at <a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Coursera</a>. The course is taught by Andrew Ng.</p><p>Almost all materials in this note come from courses’ videos. The note combines knowledge from course and some of my understanding of these konwledge. I’ve reorganized the structure of the whole course according to my understanding. Thus, it doesn’t strictly follow the order of videos.</p><p>In this note, I will keep all functions and equations vectorized (without for loop) as far as possible.</p><p>If you want to read the notes which strictly follows the course, here are some recommendations:</p><ul><li><a href="https://github.com/mbadry1/DeepLearning.ai-Summary" target="_blank" rel="noopener">mbadry1’s notes on Github</a></li><li><a href="https://github.com/ppant/deeplearning.ai-notes" target="_blank" rel="noopener">ppant’s notes on Github</a></li></ul><p>Some parts of this note are inspired from <a href="https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng" target="_blank" rel="noopener">Tess Ferrandez</a>.</p><h1 id="Brief-Intro-to-Deep-Learning"><a href="#Brief-Intro-to-Deep-Learning" class="headerlink" title="Brief Intro to Deep Learning"></a>Brief Intro to Deep Learning</h1><p>To begin with, let’s focus on some basic concepts to gain some intuition of deep learning.</p><h2 id="Stuctures-of-Deep-Learning"><a href="#Stuctures-of-Deep-Learning" class="headerlink" title="Stuctures of Deep Learning"></a>Stuctures of Deep Learning</h2><p>We start with supervised learning. Here are several types of neural network (NN) in the folloing chart:</p><table><thead><tr><th style="text-align:center">INPUT: X</th><th style="text-align:center">OUTPUT: y</th><th style="text-align:center">NN TYPE</th></tr></thead><tbody><tr><td style="text-align:center">Home features</td><td style="text-align:center">Price</td><td style="text-align:center">Standard NN</td></tr><tr><td style="text-align:center">Ad, user info</td><td style="text-align:center">Click or not</td><td style="text-align:center">Standard NN</td></tr><tr><td style="text-align:center">Image</td><td style="text-align:center">Objects</td><td style="text-align:center">Convolutional NN (CNN)</td></tr><tr><td style="text-align:center">Audio</td><td style="text-align:center">Text Transcription</td><td style="text-align:center">Recurrent NN (RNN)</td></tr><tr><td style="text-align:center">English</td><td style="text-align:center">Chineses</td><td style="text-align:center">Recurrent NN (RNN)</td></tr><tr><td style="text-align:center">Image, Radar info</td><td style="text-align:center">Position of other cars</td><td style="text-align:center">Custom NN</td></tr></tbody></table><p>Here are some pictures of Standard NN, Convolutional NN, Recurrent NN: </p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Standard_NN.png" height="70%" width="70%"><br>  <div class="image-caption">Standard NN</div><br>  <img src="/2018/10/22/DeepLearningNotes-NNandDL/Convolutional_NN.png" height="70%" width="70%"><br>  <div class="image-caption">Convolutional NN</div><br>  <img src="/2018/10/22/DeepLearningNotes-NNandDL/Recurrent_NN.png" height="70%" width="70%"><br>  <div class="image-caption">Recurrent NN</div><br></div><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>Neural Nework can deal with both stuctured data and unstructured data. The following will give you an intuition of both kinds of data.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Structured_and_Unstructured_Data.png" height="50%" width="50%"><br>  <div class="image-caption">Structured and Unstructured Data</div><br></div><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><p>Here are some conclusions of why deep learning is advanced comparing to traditional machine learning.</p><p>Firstly, deep learning models performs better when dealing with big data. Here is a comparation of deep learning models and classic machine learing models:</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Comparation_between_deep_learning_and_machine_learning.png"><br>  <div class="image-caption">Comparation between deep learning and machine learning</div><br></div><p>Secondly, thanks to the booming development of hardware and advanced algorithm, computing is much faster than before. Thus, we can implement our idea and know whether it works or not in short time. As a result, we can run the following circle much faster than we image.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Iteration_process.png" height="50%" width="50%"><br>  <div class="image-caption">Iteration process</div><br></div><h1 id="Basic-Symbols-of-the-Course"><a href="#Basic-Symbols-of-the-Course" class="headerlink" title="Basic Symbols of the Course"></a>Basic Symbols of the Course</h1><p>These basic symbols will be used through out the whole specialization.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Standard_notations.png"><br>  <div class="image-caption">Standard notations</div><br>  <img src="/2018/10/22/DeepLearningNotes-NNandDL/Standard_representations.png"><br>  <div class="image-caption">Standard representation</div><br></div><p>Moreover, in this course, each input x will be stacked into columns and form the input matrix X.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Input_X.png" width="50%" height="50%"><br>  <div class="image-caption">Input X</div><br>  <img src="/2018/10/22/DeepLearningNotes-NNandDL/Output_y.png" width="50%" height="50%"><br>  <div class="image-caption">Output y</div><br></div><h1 id="Neural-Network"><a href="#Neural-Network" class="headerlink" title="Neural Network"></a>Neural Network</h1><p>Reviewing the whole course, there are several common concepts between logistic regression and neural network (including both shallow and deep neural network). Thus, I draw conclusions on each concept and then apply them to both logistic regression and neural network.</p><h2 id="Logistic-Regression-and-Neural-Network"><a href="#Logistic-Regression-and-Neural-Network" class="headerlink" title="Logistic Regression and Neural Network"></a>Logistic Regression and Neural Network</h2><p>First of all, here are pictures of logistic regression and neural network.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Logistic_Regression.png" width="60%" height="60%"><br>  <div class="image-caption">Logistic Regression</div><br>  <img src="/2018/10/22/DeepLearningNotes-NNandDL/Neural_Network.png" width="60%" height="60%"><br>  <div class="image-caption">Neural Network</div><br></div><p>As we can see, logistic regression is also a kind of neural network, which has input layer and output layer and does not have hidden layers, so that it is also called mini neural network. In the following sections, I will write “neural network” to represent logistic regression and neural network and use pictures similar to the second one to represent neural network.</p><h2 id="Computation-Graph"><a href="#Computation-Graph" class="headerlink" title="Computation Graph"></a>Computation Graph</h2><p>Computation graph is one of basic concepts in deep learning. By analyzing it, we could understand the whole process of computation process of neural network. The following is the basic computation graph:</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Computation_Graph.png" width="80%" height="80%"></div><p>In this picture, we can easily understand how $J(a,b,c)=3(a+bc)$ is computed. This process is similar to “Forward Propagation” process which I will say in next section. Moreover, in neural network, $J$ is called cost function. After computing cost function $J$, we need to feed it back to all of our parameters, such as $a$, $b$, $c$ in the picture. This process is called computing derivatives.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Computing_Derivatives.png" width="80%" height="80%"></div><p>By analyzing the comutation graph, we can easily compute all deviatives. According to chain rule, we can compute $\frac{dJ}{da}$ by $\frac{dJ}{dv}\frac{dv}{da}$. So do parameter $b$ and $c$. The whole derivation process is similar to “backward propagation” process in neural network.</p><h2 id="Forward-Propagation"><a href="#Forward-Propagation" class="headerlink" title="Forward Propagation"></a>Forward Propagation</h2><h3 id="Computation-on-single-neuron"><a href="#Computation-on-single-neuron" class="headerlink" title="Computation on single neuron"></a>Computation on single neuron</h3><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Logistic_Regression.png" width="60%" height="60%"><br>  <div class="image-caption">Computation on single neuron</div><br></div><p>For every single neuron, the computing process is the same as the logistic regression. Logistic regression is basically the combination of linear regression and logistic function such as sigmoid. It has one input layer, x, and one output layer, a or $ \hat{y} $.</p><p>The linear regression equation is:&ensp;$ z = w^Tx+b $<br>The sigmoid function equation is:&ensp;$ a = \sigma( z ) $<br>The combination euquation is:&emsp;&ensp;&nbsp;$ \hat{y} = a = \sigma( w^Tx + b ) $</p><h3 id="The-whole-process-on-Neural-Network"><a href="#The-whole-process-on-Neural-Network" class="headerlink" title="The whole process on Neural Network"></a>The whole process on Neural Network</h3><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Forward_Propagation_NN.png" width="90%" height="90%"><br>  <div class="image-caption">Forward Propagation</div><br></div><p>This is an example of neural network. Since it only has one hidden layer, it’s also called shallow neural network. The forward propagation process means that we compute the graph from left to the right in this picture.</p><p>The whole process when computing the 1<sup>st</sup> layer (hidden layer) is as the following:</p><p>\begin{align}<br>Z^{[1]} &amp; = W^{[1]T}X + b^{[1]} \\<br>A^{[1]} &amp; = \sigma( Z^{[1]} )<br>\end{align}</p><p>In these equations:</p><ul><li>$W^{[1]T}$ is a $4 \times 3$ matrix. It is also written as $W^{[1]}$. Its shape is always $n^{[l]} \times n^{[l - 1]}$.</li><li>$X$ is a $3 \times m$ matrix. Sometimes it is also called $A^{[0]}$.</li><li>$b^{[1]}$ is a $4 \times m$ matrix. Its shape is always $n^{[l]} \times m$.</li><li>$A^{[1]}$ is a $4 \times m$ matrix. Its shape is always $n^{[l]} \times m$.</li><li>$\sigma$ is an element-wise function. It is called activation function.</li></ul><p>For each layer, it just repeats what previous layers do until the last layer (output layer).</p><h3 id="Cost-function"><a href="#Cost-function" class="headerlink" title="Cost function"></a>Cost function</h3><p>Here is a definition of loss function and cost function.</p><ul><li>Loss function computes a single training example.</li><li>Cost function is the average of the loss function of the whole training set.</li></ul><p>In traditional machine learning, we use square root error as loss function, which is $ L = \frac{1}{2}( \hat{y} - y )^2 $. But in this case, we don’t use it since most problems we try to solve are not convex.</p><p>Here is the loss function we use:</p><p>$$<br>L( \hat{y}, y ) = -( y \cdot log(\hat{y}) + ( 1 - y ) \cdot log( 1 - \hat{y} ) )<br>$$</p><p>For this loss function:</p><ul><li>if y = 1, then $ L = -y \cdot log(\hat{y}) $ and it will close to 0 when $ \hat{y} $ near 1.</li><li>if y = 0, then $ L = -( 1 - y ) \cdot log( 1 - \hat{y} ) $ and it will close to 0 when $ \hat{y} $ near 0.</li></ul><p>Then the cost function is: $$ J( w, b ) = \frac{1}{m}\sum_{i=1}^{m} L( \hat{y}, y ) $$</p><h2 id="Backward-Propagation"><a href="#Backward-Propagation" class="headerlink" title="Backward Propagation"></a>Backward Propagation</h2><p>Here, we use gradient descent as our backward propagation method.</p><h3 id="Compute-Gradients"><a href="#Compute-Gradients" class="headerlink" title="Compute Gradients"></a>Compute Gradients</h3><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Backward_Propagation_NN.png" width="90%" height="90%"><br>  <div class="image-caption">Backward Propagation</div><br></div><p>As we can see in the picture, it is a simplified computation graph. The neural network is on the right-top, which is almost the same as the neural network we discussing in previous section. Backward Propagation is computing derivatives from the right to the left. By following the backward process, we can get derivatives for all parameters, including $W^{[1]}$, $b^{[1]}$, $W^{[2]}$, $b^{[2]}$.</p><p>Here I give a rough derivation example of computing gradients of parameter $W^{[1]}$.</p><p>\begin{align}<br>\frac{\partial L}{\partial Z^{[1]}} &amp; = W^{[2]T}\frac{\partial L}{\partial Z^{[2]}} \cdot {\sigma}^{[1]\prime}(Z^{[1]}) \\<br>\frac{dL}{dW^{[1]}} &amp; = \frac{\partial L}{\partial Z^{[1]}}\frac{dZ^{[1]}}{dW^{[1]}} \\<br>                    &amp; = \frac{\partial L}{\partial Z^{[1]}}A^{[0]T} \\<br>\frac{dL}{db^{[1]}} &amp; = \frac{\partial L}{\partial Z^{[1]}}\frac{dZ^{[1]}}{db^{[1]}} \\<br>                    &amp; = \frac{\partial L}{\partial Z^{[1]}}<br>\end{align}</p><p>It is similar to compute parameters in other layers. In these equations:</p><ul><li>$\frac{dL}{dW^{[1]}}$ has the same shape as $W^{[1]}$. So do other layers.</li><li>$\frac{dL}{db^{[1]}}$ has the same shape as $b^{[1]}$. So do other layers.</li><li>the $\cdot$ in first line is an element-wise product.</li></ul><h3 id="Update-parameters"><a href="#Update-parameters" class="headerlink" title="Update parameters"></a>Update parameters</h3><p>After computing gradients, we can update our parameters quickly.</p><p>For every parameters (Take layer1 as an example):</p><p>\begin{align}<br>W^{[1]} &amp; = W^{[1]} - \alpha \frac{dL}{dW^{[1]}} \\<br>b^{[1]} &amp; = b^{[1]} - \alpha \frac{dL}{db^{[1]}}<br>\end{align}</p><p>In above equations, $\alpha$ is called learning rate, which we need to determine before training.</p><h2 id="Activation-Functions"><a href="#Activation-Functions" class="headerlink" title="Activation Functions"></a>Activation Functions</h2><p>In previous sections, notation $\sigma$ is used to represent activation function. In neural network, there are five common activation functions: Sigmoid, Tanh, ReLU, Leaky ReLU, and Exponential LU.</p><div align="center"><img src="/2018/10/22/DeepLearningNotes-NNandDL/Activation_Functions.png" width="90%" height="90%"><br>  <div class="image-caption">Activation Functions</div><br></div><p>In the course, Prof. Andrew Ng introduces the first four activation functions.</p><p>Here are some experience on choosing those activation functions:</p><ul><li><strong>Sigmoid</strong>: It is usually used in output layer to generate results between 0 and 1 when doing binary classification. In other case, you should not use it.</li><li><strong>Tanh</strong>: It always works better than sigmoid function since its value is between -1 and 1, so that neural network can learn more information by using it than using sigmoid function.</li><li><strong>ReLU</strong>: The most commonly used activation function is ReLU function. If you don’t want to use it, you can choose other ReLU derivatives, such as Leaky ReLU.</li></ul><h2 id="Parameters-and-Hyperparameters"><a href="#Parameters-and-Hyperparameters" class="headerlink" title="Parameters and Hyperparameters"></a>Parameters and Hyperparameters</h2><h2 id="Comparation-of-shallow-and-deep-neural-network"><a href="#Comparation-of-shallow-and-deep-neural-network" class="headerlink" title="Comparation of shallow and deep neural network"></a>Comparation of shallow and deep neural network</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is a note of the first course of the “Deep Learning Specialization” at &lt;a href=&quot;https://www.coursera.org/specializations/deep-learni
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://lrscy.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="https://lrscy.github.io/tags/Deep-Learning/"/>
    
      <category term="Coursera" scheme="https://lrscy.github.io/tags/Coursera/"/>
    
  </entry>
  
  <entry>
    <title>数据清洗工具及相关使用方法</title>
    <link href="https://lrscy.github.io/2018/03/20/Data-clean-for-Machine-Translation-CE/"/>
    <id>https://lrscy.github.io/2018/03/20/Data-clean-for-Machine-Translation-CE/</id>
    <published>2018-03-20T18:50:09.000Z</published>
    <updated>2018-03-20T09:42:40.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近跟着老师参加了CWMT评测任务，稍微整理下目前用到的数据清洗相关的工具及使用方法。本人目前操作全在Ubuntu16.04下进行。</p><h1 id="中文分词工具ansj"><a href="#中文分词工具ansj" class="headerlink" title="中文分词工具ansj"></a>中文分词工具ansj</h1><h2 id="安装ansj"><a href="#安装ansj" class="headerlink" title="安装ansj"></a>安装ansj</h2><p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener">Ansj的Github地址</a></p><p>首先需要下载两个jar包<a href="https://oss.sonatype.org/content/repositories/releases/org/ansj/ansj_seg/" target="_blank" rel="noopener"><code>ansj_seg</code></a>和<a href="https://oss.sonatype.org/content/repositories/releases/org/nlpcn/nlp-lang/" target="_blank" rel="noopener"><code>nlp-lang</code></a>。一般来说都下载最新的jar包都不会有问题，只用下文件夹内名字最短的哪个jar包就可以了。如果需要用老版的<code>ansj_seg</code>的话，要去jar包中的<code>.pom</code>文件中看下对应<code>nlp-lang</code>的jar包，然后下载。</p><p>下载完了后在IDE中将jar包引入即可。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>目前我使用的分词方式时精准分词，函数为<code>ToAnalysis.parse()</code>。其余方法请移步<a href="https://github.com/NLPchina/ansj_seg/wiki/%E5%88%86%E8%AF%8D%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">Ansj的wiki</a>查看。<br>分词后的输出是带有词性的，使用<code>toStringWithOutNature</code>函数可以去掉词性。</p><p>核心代码样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result parse = ToAnalysis.parse( tmpString );</span><br><span class="line">String resultStr = parse.toStringWithOutNature( <span class="string">" "</span> );</span><br></pre></td></tr></table></figure></p><h1 id="英文分词工具tokenizer-perl"><a href="#英文分词工具tokenizer-perl" class="headerlink" title="英文分词工具tokenizer.perl"></a>英文分词工具tokenizer.perl</h1><p><code>tokenizer.perl</code>是统计机器翻译系统moses的一个小工具，可以用来对英文德文等进行分词。</p><h2 id="安装tokenizer-perl"><a href="#安装tokenizer-perl" class="headerlink" title="安装tokenizer.perl"></a>安装tokenizer.perl</h2><p>因为该脚本并不是独立运行的，其需要moses自带的一些词库。moses整体不大，建议整体都下载下来。从<a href="https://github.com/moses-smt/mosesdecoder" target="_blank" rel="noopener">moses的Github</a>下载即可。该工具位置在<code>[mosesdecoder dir]/scirpts/tokenizer/</code>目录下。</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><p>建议将待分词文件放在上述文件夹下进行分词操作。输入如下命令进行分词：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl tokenizer.perl -l en &lt; [untokenized file] &gt; [tokenized file]</span><br></pre></td></tr></table></figure></p><p>其中：</p><ol><li><code>-l</code>是语言选择，这里选择<code>en</code>即英文。</li><li><code>&lt;</code>代表输入，<code>[untokenized file]</code>是待分词文件</li><li><code>&gt;</code>代表输出，<code>[tokenized file]</code>是分词后的输出文件，如果这个文件不存在则会创建同名文件。 </li></ol><p>其他用法可以输入下述命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ perl tokenizer.perl -h</span><br></pre></td></tr></table></figure></p><h1 id="词对齐工具fast-align"><a href="#词对齐工具fast-align" class="headerlink" title="词对齐工具fast_align"></a>词对齐工具fast_align</h1><h2 id="安装fast-align"><a href="#安装fast-align" class="headerlink" title="安装fast_align"></a>安装fast_align</h2><p>安装过程翻译自<a href="https://github.com/clab/fast_align" target="_blank" rel="noopener">fast_align的Github</a></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>在Ubuntu系统上输入以下命令配置环境，其他系统请自行搜索相对应的安装包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install libgoogle-perftools-dev libsparsehash-dev</span><br></pre></td></tr></table></figure></p><p>如果系统中没有安装<code>cmake</code>请输入以下命令进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br></pre></td></tr></table></figure></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进入<code>fast_align</code>文件夹，顺序执行下述命令进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure></p><p>上述命令中<code>..</code>表示的是上一层文件夹，即<code>fast_align</code>文件夹。<br>安装完成后出现<code>fast_align</code>和<code>atool</code>两个文件即表示成功安装。</p><h2 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h2><p>如果平行预料库源语言和目标语言文件是分开的，则需要手动将其合并成一个文件，格式为：[源语言句子] ||| [目标语言句子]。注意，在”|||”前后是有空格分开的。</p><p>样例Python程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">( src, trg, out )</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open( src ) <span class="keyword">as</span> fs, <span class="keyword">with</span> open( trg ) <span class="keyword">as</span> ft, <span class="keyword">with</span> open( out ) <span class="keyword">as</span> fo:</span><br><span class="line">        <span class="keyword">for</span> lines, linef <span class="keyword">in</span> zip( fs, ft ):</span><br><span class="line">            fo.write( lines.strip() + <span class="string">" ||| "</span> + linef.strip() )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len( sys.argv ) != <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"USAGE: ./python merge.py [src file] [trg file] [out file]"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        merge( sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>] )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>在<code>build</code>文件夹下执行下述命令进行正向词对齐：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./fast_align -i [filename] -d -o -v &gt; [align_forward_filename]</span><br></pre></td></tr></table></figure></p><p>然后在<code>build</code>文件夹下执行下述命令进行反向词对齐：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./fast_align -i [filename] -d -o -v -r &gt; [align_reverse_filename]</span><br></pre></td></tr></table></figure></p><p>最后在<code>build</code>文件夹下执行下述命令进行双向词对齐获得最终词对齐文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./atool -i [align_forward_filename] -j [align_reverse_filename] -c grow-diag-final-and &gt; [align_file_name]</span><br></pre></td></tr></table></figure></p><p>生成文件格式为<code>i-j</code>的格式，<code>i</code>代表<code>-i</code>文件中该行第<code>i</code>个词，<code>j</code>代表<code>-j</code>文件中该行第<code>j</code>个词。得到最终结果后，中间结果可以删除掉。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>fast_align本身线程不安全，尽量不要一次执行多个fast_align程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近跟着老师参加了CWMT评测任务，稍微整理下目前用到的数据清洗相关的工具及使用方法。本人目前操作全在Ubuntu16.04下进行。&lt;/p&gt;
&lt;h1 id=&quot;中文分词工具ansj&quot;&gt;&lt;a href=&quot;#中文分词工具ansj&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="NLP" scheme="https://lrscy.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://lrscy.github.io/tags/NLP/"/>
    
      <category term="NMT" scheme="https://lrscy.github.io/tags/NMT/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16 Y轴翻转</title>
    <link href="https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/"/>
    <id>https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/</id>
    <published>2018-02-12T01:42:15.000Z</published>
    <updated>2018-02-11T14:17:51.903Z</updated>
    
    <content type="html"><![CDATA[<p>Cocos2d-x的设计中，setPosition等的原点是在屏幕左下角。例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/Normal.png" alt="正常坐标系" title="">                </div>                <div class="image-caption">正常坐标系</div>            </figure><p>但是当把触摸点坐标转换到屏幕坐标点时发现其原点在左上角。例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/Touch.png" alt="触摸坐标系" title="">                </div>                <div class="image-caption">触摸坐标系</div>            </figure><p>这样设计的好处是自然的支持纵向的“自然滚动”（即向下划的时候上面的内容自然出现，反之亦然）。然而当不需要这个功能的时候，会在坐标变换上小折腾下。</p><p>由于在处理多点触碰和缩放时候这个坐标转换耗费了不少的时间，为了以后懒得在这个上面再费时间和脑力（就是懒emmmm），归纳一点：“<code>旧纵坐标减新纵坐标</code>”。今后再有类似问题就来看着这条改下就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cocos2d-x的设计中，setPosition等的原点是在屏幕左下角。例如：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                   
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Axis" scheme="https://lrscy.github.io/tags/Axis/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2dx-3.16-Android-Multi-Touch</title>
    <link href="https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/"/>
    <id>https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/</id>
    <published>2018-02-12T01:40:58.000Z</published>
    <updated>2018-02-14T06:06:44.165Z</updated>
    
    <content type="html"><![CDATA[<p>网上有关Cocos2d-x v3.x版本的多点触控的资料并不多，在尝试时发现了如下几个坑。跳出坑最好的办法就是去读官方给出的Testapp的源码，这样能看快的了解到官方时如何使用各种功能的，模仿和学起来都很快且很到位。如果更有能力的去多看看API和源码也是很好的学习途径。</p><h1 id="onTouchesBegan-Moved-Ended-Cancelled函数的参数"><a href="#onTouchesBegan-Moved-Ended-Cancelled函数的参数" class="headerlink" title="onTouchesBegan/Moved/Ended/Cancelled函数的参数"></a>onTouchesBegan/Moved/Ended/Cancelled函数的参数</h1><p>网上众多教程基本都是基于2.x版本，所用函数名及参数有许多为<code>cc</code>开头，且触摸回调函数的参数基本为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MoreTouches::ccTouchesMoved( cocos2d::CCSet *pTouches,</span><br><span class="line">                                  cocos2d::CCEvent *pEvent );</span><br></pre></td></tr></table></figure></p><p>在当前3.16版本中，其改为了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTouchesBegan</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cocos2d::Touch *&gt; &amp;touches,</span></span></span><br><span class="line"><span class="function"><span class="params">                     cocos2d::Event *event )</span></span>;</span><br></pre></td></tr></table></figure></p><p>不再使用<code>set</code>作为触摸点的存储结构，而是采用<code>vector</code>。</p><h1 id="onTouchesBegan-onTouchesEnded传入参数touches的问题"><a href="#onTouchesBegan-onTouchesEnded传入参数touches的问题" class="headerlink" title="onTouchesBegan/onTouchesEnded传入参数touches的问题"></a>onTouchesBegan/onTouchesEnded传入参数touches的问题</h1><p>先说<code>onTouchesBegan</code>函数的传入参数。<code>onTouchesEnded</code>和<code>onTouchesBegan</code>的逻辑几乎是一样的。</p><p>开始参考网上多点触控的代码进行实验，但是在<code>onTouchesBegan</code>回调函数上永远出问题，后来发现<code>onTouchesBegan</code>回调函数的<code>touches</code>参数永远只存了一个变量（那你用vector存什么呀啊喂！）。在进行了众多测试以及上网寻找资料（不小心还挖了个坟emmmm）后决定仔细研究下官方的Testapp源码。</p><p>原先模仿网上函数写法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hello::onTouchesBegan( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cocos2d::Touch *&gt; &amp;touches,</span><br><span class="line">                            cocos2d::Event *event ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( touches.size() &gt;= <span class="number">2</span> ) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的<code>touches.size()</code>的值永远是<code>1</code>。官方给出的<code>MultiTouch</code>的源代码部分如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;<span class="keyword">int</span>, TouchPoint *&gt; s_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MultiTouchTest::onTouchesBegan( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Touch *&gt; &amp;touches,</span><br><span class="line">                                     Event *event ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;item: touches ) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最开始看代码的时候还一脸欢喜，这官方给的例子不是明显的在说<code>touches</code>里面会存多变量的么。直到我用<code>log</code>打出来<code>touches.size()</code>后才“惊喜”的发现这值也是<code>1</code>（那你用vector干嘛呢遍历啥呢啊喂！）。</p><p>目前反推<code>onTouchesBegan</code>的设计逻辑是说一个指头的触摸激活一次<code>onTouchesBegan</code>，每个触摸的初始化单独做一次。这样的好处在于当多指相差时间很长才都按到屏幕上时，也能可以通过设计逻辑很容易的将其识别为多指操作，而不是多次单指操作。就算真的物理上是同时按住的时候也可能会给序列化处理成先后两次触摸。唯独麻烦的一点就是程序逻辑设计上要费点心思了。</p><p>目前本人的方法是将所有<code>onTouchesBegan</code>读取到的触摸都<code>push_back</code>到一个<code>vector</code>中，在<code>onTouchesMoved</code>中分类处理，最终每触发一次<code>onTouchesEnded</code>时就<code>pop_back</code>掉一次。至于为什么没用<code>stack</code>结构，因为处理<code>onTouchesMoved</code>处理时候的读取用<code>vector</code>方便些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上有关Cocos2d-x v3.x版本的多点触控的资料并不多，在尝试时发现了如下几个坑。跳出坑最好的办法就是去读官方给出的Testapp的源码，这样能看快的了解到官方时如何使用各种功能的，模仿和学起来都很快且很到位。如果更有能力的去多看看API和源码也是很好的学习途径。&lt;
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android" scheme="https://lrscy.github.io/tags/Android/"/>
    
      <category term="Multi Touch" scheme="https://lrscy.github.io/tags/Multi-Touch/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16 Android Studio添加新类</title>
    <link href="https://lrscy.github.io/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/"/>
    <id>https://lrscy.github.io/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/</id>
    <published>2018-02-04T01:29:01.000Z</published>
    <updated>2018-02-11T13:56:58.662Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Android Studio编辑Cocos2d-x项目时，如果想添加一个Class进去，除了建立相对应的<code>.h</code>和<code>.cpp</code>以外，还需要让编译配置文件知道这个文件属于该项目。然而Android Studio 3.x版本自动同步时并不能将新类中的<code>.cpp</code>问家加入编译配置文件中。</p><p>后来发现在左侧<code>External Build Files</code>中，有个叫做<code>Android.mk</code>的文件，需要在其中的<code>LOCAL_SRC_FILES</code>变量中加入新的<code>.cpp</code>文件。即：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := <span class="variable">$(LOCAL_PATH)</span>/hellocpp/main.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/AppDelegate.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/HelloWorldScene.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/Hello.cpp</span><br></pre></td></tr></table></figure></p><p>想必大家都读得懂怎么向这个变量中加入新的文件，其中<code>Hello.cpp</code>就是我添加的新<code>.cpp</code>文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Android Studio编辑Cocos2d-x项目时，如果想添加一个Class进去，除了建立相对应的&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.cpp&lt;/code&gt;以外，还需要让编译配置文件知道这个文件属于该项目。然而Android Studio 3.x版本自动
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android Studio" scheme="https://lrscy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下TensorFlow安装</title>
    <link href="https://lrscy.github.io/2018/02/02/Ubuntu-Tensorflow-config/"/>
    <id>https://lrscy.github.io/2018/02/02/Ubuntu-Tensorflow-config/</id>
    <published>2018-02-02T18:29:40.000Z</published>
    <updated>2018-02-02T10:46:53.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TensorFlow安装环境为<code>Ubuntu 16.04.3 LTS</code>，GPU为<code>GT 750M</code>。</p><p>假设目前已经安装好了<code>CUDA8</code>，如果没有安装请依照「<a href="/2018/02/01/Ubuntu-CUDA-Tookit-8-Install">Ubuntu 16.04下CUDA Tookit 8安装</a>」进行安装。</p><p>如果有一定英语能力的同学最好请移步<a href="https://www.tensorflow.org/install/install_linux" target="_blank" rel="noopener">官网</a>进行下载安装，尽管可能需要下科学上网。</p><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><p>本文采用Virtualenv环境进行搭建，这样能将TensorFlow运行于一个分离开的Python环境下，免得今后出错时对整个系统产生影响。</p><h2 id="CUPTI环境搭建"><a href="#CUPTI环境搭建" class="headerlink" title="CUPTI环境搭建"></a>CUPTI环境搭建</h2><p>CUPTI库能够提高可以提高CUDA的性能，官方要求安装。</p><p>如果CUDA Tookit &gt;= 8.0，输入如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cuda-command-line-tools</span><br></pre></td></tr></table></figure></p><p>并且在CUDA安装时所设定的<code>LD_LIBRARY_PATH</code>添加路径至如下状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda/extras/CUPTI/lib64</span><br></pre></td></tr></table></figure></p><p>如果CUDA Tookit &lt;= 7.5或者上述命令无法执行，请输入如下命令安装CUPTI库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcupti-dev</span><br></pre></td></tr></table></figure></p><h2 id="pip环境搭建"><a href="#pip环境搭建" class="headerlink" title="pip环境搭建"></a>pip环境搭建</h2><p>下面两行中选择一行执行即可，依据个人Python版本选择：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python-pip  python-dev  python-virtualenv <span class="comment"># for Python 2.7</span></span><br><span class="line">$ sudo apt install python3-pip python3-dev python-virtualenv <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p>本人选择的是<code>Python2.7</code>，因为<code>Ubuntu 16.04.3</code>默认<code>Python</code>为<code>Python 2.7</code>，改默认会影响<code>ibus-pinyin</code>（输入法）的更新和运行。</p><h2 id="Virtualenv环境搭建"><a href="#Virtualenv环境搭建" class="headerlink" title="Virtualenv环境搭建"></a>Virtualenv环境搭建</h2><p>下面两行中选择一行执行即可，依据个人Python版本选择：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --system-site-packages targetDirectory            <span class="comment"># for Python 2.7</span></span><br><span class="line">$ virtualenv --system-site-packages -p python3 targetDirectory <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p>其中<code>targetDirectory</code>是隔离环境的根目录，需要自行设定。个人设定是<code>~/tensorflow</code>，下文暂且按照这个目录进行介绍。</p><p>至此，基础观景搭建完成。</p><h1 id="TensorFlow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h1><h2 id="进入Virtualenv环境"><a href="#进入Virtualenv环境" class="headerlink" title="进入Virtualenv环境"></a>进入Virtualenv环境</h2><p>输入如下命令进入Virtualenv环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/tensorflow/bin/activate      <span class="comment"># bash, sh, ksh, or zsh</span></span><br><span class="line">$ <span class="built_in">source</span> ~/tensorflow/bin/activate.csh  <span class="comment"># csh or tcsh</span></span><br></pre></td></tr></table></figure></p><p>请依据自身<code>shell</code>环境选择，一般Ubuntu原生使用的是<code>sh</code>。</p><p>这里可以在<code>~/.bashrc</code>中输入如下命令使得命令简化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> tensorflow=<span class="string">"source ~/tensorflow/bin/activate"</span>      <span class="comment"># bash, sh, ksh, or zsh</span></span><br><span class="line"><span class="built_in">alias</span> tensorflow=<span class="string">"source ~/tensorflow/bin/activate.csh"</span>  <span class="comment"># csh or tcsh</span></span><br></pre></td></tr></table></figure></p><p>请依据自身的<code>shell</code>环境选择第一条还是第二条。其中<code>tensorflow</code>可以自行拟定。</p><p>当编辑完后在命令行中输入如下命令使其立即生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>以后在命令行中输入<code>tensorflow</code>即可调出该<code>Virtualenv</code>环境。</p><p>当前环境应该如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) xxx@xxx:path$</span><br></pre></td></tr></table></figure></p><ol><li><code>tensorflow</code>即<code>Virtualenv</code>文件夹名称，下文按照<code>tensorflow</code>描述。</li><li><code>xxx@xxx:path</code>与未进入<code>Virtualenv</code>环境时无差别。下文中将简化描述为<code>(tensorflow) $</code></li></ol><h2 id="更新pip"><a href="#更新pip" class="headerlink" title="更新pip"></a>更新pip</h2><p>为了确保pip version &gt;= 8.1，输入如下命令更新pip：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install --upgrade pip  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade pip <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><h2 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h2><p>如果系统中的<code>CUDA Tookit</code>和<code>cuDNN</code>都是最新版，请从以下四条命令中选择一个来安装TensorFlow：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install --upgrade tensorflow      <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade tensorflow     <span class="comment"># for Python 3.x</span></span><br><span class="line">(tensorflow) $ pip install --upgrade tensorflow-gpu  <span class="comment"># for Python 2.7 and GPU</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade tensorflow-gpu <span class="comment"># for Python 3.x and GPU</span></span><br></pre></td></tr></table></figure></p><p>前两条是仅使用CPU的版本，后两条的版本能够使用GPU。</p><p>如果系统中的<code>CUDA Tookit</code>和<code>cuDNN</code>并非最新版，按照上述安装很可能会出现问题导致重装。因此安装前请先完成如下几步：</p><ol><li>请先确定系统中的<code>cuDNN</code>和<code>CUDA Tookit</code>时想匹配的，具体版本匹配详见<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">官网</a>。</li><li>请在<a href="https://github.com/tensorflow/tensorflow/releases" target="_blank" rel="noopener">TensorFlow的Github Release</a>中寻找符合自己<code>CUDA Tookit</code>和<code>cuDNN</code>的版本。</li><li>依照选好的版本拼凑网址。</li></ol><p>拼凑网址如下，请依据CPU以及GPU从两条中选择一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># for CPU only</span><br><span class="line">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-x.x.x-cpxx-none-linux_x86_64.whl</span><br><span class="line"># for GPU support</span><br><span class="line">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-x.x.x-cpxx-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure></p><p>其中：</p><ol><li><code>x.x.x</code>是从<code>release</code>中选择出的需要的版本。</li><li><code>cpxx</code>是本机<code>python</code>的版本，例如：<code>2.7.xx</code>为<code>27</code>，<code>3.5.xx</code>的版本为<code>35</code>，以此类推。</li><li><code>storage.googleapis.com</code>可能需要科学上网才能访问。</li></ol><p>然后进行Tensorflow的安装，输入如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install yourhttpsite  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install yourhttpsite <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p><code>yourhttpsite</code>就是拼凑出来的网址。</p><p>如果pip提示无法从代理处下载文件，则可以先将文件从网址下载下来并存在<code>~</code>（即家目录）或者自定义目录下，然后通过如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install filename  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install filename <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p><code>filename</code>即下载的<code>.whl</code>文件（可能需要输入完整路径）。</p><h1 id="TensorFlow的使用"><a href="#TensorFlow的使用" class="headerlink" title="TensorFlow的使用"></a>TensorFlow的使用</h1><h2 id="启动TensorFlow环境"><a href="#启动TensorFlow环境" class="headerlink" title="启动TensorFlow环境"></a>启动TensorFlow环境</h2><p>请参照<a href="#进入Virtualenv环境">进入Virtualenv环境</a>步骤进行。</p><h2 id="测试TensorFlow环境"><a href="#测试TensorFlow环境" class="headerlink" title="测试TensorFlow环境"></a>测试TensorFlow环境</h2><p>先进入TensorFlow环境，然后输入如下代码进行测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p><p>输出<code>Hello, TensorFlow!</code>且无报错即可。如果报错请参考<a href="https://www.tensorflow.org/install/install_linux#CommonInstallationProblems" target="_blank" rel="noopener">官网</a>或者上网寻找解决方案。</p><h2 id="退出TensorFlow环境"><a href="#退出TensorFlow环境" class="headerlink" title="退出TensorFlow环境"></a>退出TensorFlow环境</h2><p>在环境中输入<code>deactivate</code>即可，即：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ deactivate</span><br></pre></td></tr></table></figure></p><h1 id="TensorFlow的卸载"><a href="#TensorFlow的卸载" class="headerlink" title="TensorFlow的卸载"></a>TensorFlow的卸载</h1><p>卸载时直接将其所在的Virtualenv文件夹删除即可，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf targetDirectory</span><br></pre></td></tr></table></figure></p><p><code>targetDirectory</code>即Virtualenv环境文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TensorFlow安装环境为&lt;code&gt;Ubuntu 16.04.3 LTS&lt;/code&gt;，GPU为&lt;code&gt;GT 750M&lt;/code
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Tensorflow" scheme="https://lrscy.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下CUDA Tookit 8安装</title>
    <link href="https://lrscy.github.io/2018/02/01/Ubuntu-CUDA-Tookit-8-Install/"/>
    <id>https://lrscy.github.io/2018/02/01/Ubuntu-CUDA-Tookit-8-Install/</id>
    <published>2018-02-01T16:39:17.000Z</published>
    <updated>2018-02-03T04:26:07.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵重做系统把之前的安装教程的博客给弄丢了，现在重写一份做记录好了。目前老环境还是要<code>CUDA Tookit 8</code>（以下简称<code>CUDA8</code>），因此目前先不安装CUDA最新的<code>CUDA9</code>了。</p><p>本教程是在Ubuntu 16.04.3 LTS上进行的，其他版本的Ubuntu系统请自行实验，目前在Ubuntu 17.10系统上实验成功。</p><p>当前假设Ubuntu系统已经安装完成，目前直接进行CUDA8的安装。</p><h1 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h1><h2 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h2><p>安装CUDA8需要基础的编译环境，需要检测下系统上是否安装了<code>gcc</code>或<code>g++</code>。命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v</span><br><span class="line">$ g++ -v</span><br></pre></td></tr></table></figure></p><p>如果任意一个出现版本信息就代表安装过了。如果都没有出现版本信息，则请采用如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential</span><br></pre></td></tr></table></figure></p><p>安装完成即可，网上有说CUDA8不支持<code>g++ 5.0</code>以上的版本，目前本人没有遇上这个问题。</p><h2 id="附加环境安装"><a href="#附加环境安装" class="headerlink" title="附加环境安装"></a>附加环境安装</h2><p>有些人在上述基础环境下安装完CUDA8后会出现<code>Missing recommended library: libGLU.so</code>的提示。如果不确定当前环境想提前避免这个问题，请安装如下包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libglu1-mesa libxi-dev libxmu-dev libglu1-mesa-dev</span><br></pre></td></tr></table></figure></p><p>至此，基础环境都安装完了。</p><h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><p>个人强烈建议先装NVIDIA驱动，因为CUDA8自带的驱动实在是容易出问题。驱动安装详见「<a href="/2017/10/10/Ubuntu-NVIDIA-Driver-Install">Ubuntu系统NVIDIA显卡驱动安装</a>」。</p><h1 id="CUDA8安装配置"><a href="#CUDA8安装配置" class="headerlink" title="CUDA8安装配置"></a>CUDA8安装配置</h1><h2 id="CUDA8下载"><a href="#CUDA8下载" class="headerlink" title="CUDA8下载"></a>CUDA8下载</h2><p>先从<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">官网下载</a>CUDA的驱动。目前CUDA的最新版本是<code>CUDA9</code>，要下老版本的话请采用如下<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">官方网址</a>，下载<code>Base Installer</code>和<code>Patch 2</code>。</p><p>个人建议先将文件都下载到家目录(<code>~</code>)底下，因为如果系统是中文环境的话，后续安装可能会出现文件夹名乱码的情况。安装完成后可以移动到自己想移动的位置。</p><h2 id="CUDA8安装"><a href="#CUDA8安装" class="headerlink" title="CUDA8安装"></a>CUDA8安装</h2><p>是否进入<code>tty1</code>环境看个人，本人之前各种重装驱动给吓怕了，不确定图形界面是否影响到了，因此直接进入了<code>tty1</code>环境进行CUDA8的安装。关闭图形界面的步骤如下：</p><ol><li>首先按住<code>Ctrl+Alt+F1</code>进入<code>tty1</code></li><li>输入用户名和密码</li><li>执行<code>sudo service lightdm stop</code>命令关闭图形界面。</li></ol><p>然后在安装文件所在目录下执行如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 755 (CUDA Install File)</span><br><span class="line">$ sudo ./(CUDA Install File)</span><br></pre></td></tr></table></figure></p><p>其中<code>CUDA Install File</code>是个人CUDA安装文件的名字（包括文件后缀）。</p><p>安装关键过程如下（先后顺序记不清了）：</p><ol><li>安装过程中先阅读完一大串协议，按住<code>d</code>往下（这样跳得很快），直到最后。然后输入accept。</li><li>会询问是否安装<code>NVIDIA DRIVER</code>，输入<code>n</code>。</li><li>询问是否安装<code>OPENGL</code>时输入<code>n</code>。（记得有这个问题的，这里是个大坑！！）</li><li>其他默认选择<code>y</code>或者<code>空着</code>（就是直接按回车）就行。</li></ol><p>到最后可能会出现<code>INCOMPLETE INSTALL</code>，这里不用管。这是因为你没装它的驱动而已。如果出现<code>Missing recommended library: libGLU.so</code>的提示，请参考<a href="#附加环境安装">附加环境安装</a></p><p>等一切都安装好后重启即可。</p><h2 id="补丁安装"><a href="#补丁安装" class="headerlink" title="补丁安装"></a>补丁安装</h2><p>是否进入<code>tty1</code>环境依旧看个人，具体参考上一节开头。</p><p>安装时执行如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 755 (CUDA Patch File)</span><br><span class="line">$ sudo ./(CUDA Patch File)</span><br></pre></td></tr></table></figure></p><p>其中<code>CUDA Patch File</code>是之前下载的CUDA8的补丁文件<code>Patch 2</code>。安装过程和前一节类似，基本上直接一路默认就行。</p><p>等一切安装完了后重启即可。</p><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>个人习惯在<code>/etc/profile.d</code>下设置环境变量。先进入该文件夹，然后执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo touch cuda.sh</span><br><span class="line">$ sudo vim cuda.sh</span><br></pre></td></tr></table></figure></p><p>这里<code>vim</code>可以换成<code>gedit</code>或者其他熟悉的编辑器。如果不熟悉<code>vim</code>的同学无意间进去了，输入<code>:q</code>退出<code>vim</code>。</p><p>在编辑器中输入如下文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda-8.0</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-8.0/bin</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64</span><br></pre></td></tr></table></figure></p><p>然后保存重启即可。</p><h2 id="cuDNN安装"><a href="#cuDNN安装" class="headerlink" title="cuDNN安装"></a>cuDNN安装</h2><p><code>cuDNN</code>是个GPU加速库，能为深度学习网络的计算加速。在<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">官网</a>下载。下载前可能需要先注册<code>NVIDIA DEVELOPER</code>。注册过程很简单，注册完成后选择支持<code>CUDA8.0</code>的<code>cuDNN</code>下载即可。</p><p>在下载目录解压后进入<code>cuda</code>文件夹，这里会见到<code>include</code>和<code>lib64</code>两个文件夹。这里建议在命令行下执行，因为会用到<code>sudo</code>进行暂时的root权限申请。输入如下命令进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include</span><br><span class="line">$ sudo cp lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64</span><br></pre></td></tr></table></figure></p><p>然后进入<code>/usr/local/cuda/lib64</code>文件夹中，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm libcudnn.so libcudnn.so.6</span><br><span class="line">$ sudo ln -s libcudnn.so.6.0.20 libcudnn.so.6</span><br><span class="line">$ sudo ln -s libcudnn.so.6 libcudnn.so</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>这里<code>.6</code>和<code>.6.0.20</code>是下载的cuDNN的版本号，请依据个人下载的实际版本进行修改。</p><p>至此，cuDNN已经安装完成。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，整个CUDA Tookit 8的所有安装过程就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前一阵重做系统把之前的安装教程的博客给弄丢了，现在重写一份做记录好了。目前老环境还是要&lt;code&gt;CUDA Tookit 8&lt;/code&gt;（
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="CUDA" scheme="https://lrscy.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16 屏幕显示偏移</title>
    <link href="https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Display-Offset/"/>
    <id>https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Display-Offset/</id>
    <published>2018-01-27T01:28:36.000Z</published>
    <updated>2018-02-11T13:56:47.978Z</updated>
    
    <content type="html"><![CDATA[<p>在v3.16前，屏幕上显示Sprites, Nodes都是直接使用Director类获取可视区大小并直接在上面定位Nodes的，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> size = Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create( <span class="string">"HelloWorld.png"</span> );</span><br><span class="line">sprite.setPosition( size.width / <span class="number">2</span>, size.height / <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><p>目前不知道时从哪个版本开始的，直接使用上述代码会导致<code>sprite</code>下偏移(沿y轴)一定量但无左右偏移(沿x轴)。查找资料未果后看Helloworld样例，发现其用到了Director类中另一个变量纠正这个问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();</span><br></pre></td></tr></table></figure></p><p>这里<code>origin</code>是真正的屏幕左下角的位置，所有屏幕上的显示的图像都要依据这个坐标进行调整。也就是说上述代码要改成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> size = Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create( <span class="string">"HelloWorld.png"</span> );</span><br><span class="line">sprite.setPosition( origin.x + size.width / <span class="number">2</span>, origin.y + size.height / <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><p>这时，屏幕偏移问题解决了，<code>sprite</code>也在屏幕的真正的正中央。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在v3.16前，屏幕上显示Sprites, Nodes都是直接使用Director类获取可视区大小并直接在上面定位Nodes的，例如：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Display Offset" scheme="https://lrscy.github.io/tags/Display-Offset/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16踩过的坑</title>
    <link href="https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Problems/"/>
    <id>https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Problems/</id>
    <published>2018-01-26T21:35:23.000Z</published>
    <updated>2018-02-11T13:58:01.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近刚碰关于Cocos2d-x的知识，也上网查过很多资料，但是很少有讲最新v3.16的博客。因此在此记录下使用v3.16时候遇上的坑。且会不定期更新该篇博客。</p><p>UPDATE 2018.02.11:之前是写在一起的，但是看起来太乱，就拆分到各自单独篇章中去了，这里只做个目录。</p><ol><li><a href="/2018/01/26/Cocos2dx-3-16-Display-Offset">屏幕显示偏移</a></li><li><a href="/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class">Android Studio添加新类</a></li><li><a href="/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch">多点触控</a></li><li><a href="/2018/02/11/Cocos2dx-3-16-Y-axis-Flip">Y轴翻转</a></li></ol><p>To be continue…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近刚碰关于Cocos2d-x的知识，也上网查过很多资料，但是很少有讲最新v3.16的博客。因此在此记录下使用v3.16时候遇上的坑。且会不
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android Studio" scheme="https://lrscy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>在Github上备份Hexo博客</title>
    <link href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/"/>
    <id>https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/</id>
    <published>2018-01-26T17:57:56.000Z</published>
    <updated>2018-05-30T15:11:38.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。</p><p>目前假设Git和Github环境已经配置好了，如果没有配置好详见「<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>」。<br>Git相关操作请参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a>。</p><h1 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h1><p>目前假设本地Hexo博客已经初始化，如果没有配置好Hexo博客详见「<a href="/2017/11/10/Ubuntu-Github-io-config-Hexo">Ubuntu16.04下从零起步搭建配置github.io博客————Hexo</a>」。</p><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在Github.io上建立博客时已经开了一个新仓库了，如果再开另一个仓库存放源代码有点浪费，因此采用建立新分支的方法备份博客。</p><p>虽然理论上什么时候创建新分支来备份都可以，但是还是建议在建立博客的时候就创建备份分支。（然而我中途才想起来-.-）</p><p>不过在建立新分支前请确保仓库内已有<code>master</code>分支（Hexo本地建站后第一次上传时会自动生成），否则后期再添加<code>master</code>分支比较麻烦（请自行搜索<code>git</code>命令）。</p><p>本地Git建立新分支命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b BRANCHNAME</span><br></pre></td></tr></table></figure></p><p><code>BRANCHNAME</code>是自定义的新分支的名字，建议起为<code>hexo</code>。</p><h2 id="建立-gitignore"><a href="#建立-gitignore" class="headerlink" title="建立.gitignore"></a>建立.gitignore</h2><p>建立<code>.gitignore</code>文件将不需要备份的文件屏蔽。个人的<code>.gitignore</code>文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><h2 id="在Github上备份"><a href="#在Github上备份" class="headerlink" title="在Github上备份"></a>在Github上备份</h2><p>通过如下命令将本地文件备份到Github上。</p><p>假设目前在hexo博客的根目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"Backup"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样就备份完博客了且在Github上能看到两个分支(<code>master</code>和<code>hexo</code>)。</p><h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>在Github上你的github.io仓库中设置默认分支为<code>hexo</code>。这样有助于之后恢复博客。<code>master</code>分支时默认的博客静态页面分支，在之后恢复博客的时候并不需要。</p><h2 id="个人备份习惯"><a href="#个人备份习惯" class="headerlink" title="个人备份习惯"></a>个人备份习惯</h2><p>个人而言习惯于先备份文件再生成博客。即先执行<code>git add .</code>,<code>git commit -m &quot;Backup&quot;</code>,<code>git push origin hexo</code>将博客备份完成，然后执行<code>hexo g -d</code>发布博客。</p><h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>目前假设本地Hexo博客基础环境已经搭好，如果没有配置好Hexo博客基础环境详见「<a href="/2017/11/10/Ubuntu-Github-io-config-Hexo#基础环境搭建">Ubuntu16.04下从零起步搭建配置github.io博客————Hexo</a>」。</p><h2 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(<code>hexo</code>分支)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/yourgithubname/yourgithubname.github.io</span><br></pre></td></tr></table></figure></p><h2 id="恢复博客-1"><a href="#恢复博客-1" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>在克隆的那个文件夹下输入如下命令恢复博客：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></p><p>在此不需要执行<code>hexo init</code>这条指令，因为不是从零搭建起新博客。</p><p>完成喵～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="https://lrscy.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中图片插入问题</title>
    <link href="https://lrscy.github.io/2018/01/26/Hexo-Picture-Insert/"/>
    <id>https://lrscy.github.io/2018/01/26/Hexo-Picture-Insert/</id>
    <published>2018-01-26T14:59:05.000Z</published>
    <updated>2018-02-03T04:25:47.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在用Hexo搭建博客时有时需要插入图片，但是原生Hexo对图片管理的支持不是很好。此篇博客记录利用插件和Hexo的配置解决这个问题。</p><h1 id="config-yml配置更改"><a href="#config-yml配置更改" class="headerlink" title="_config.yml配置更改"></a>_config.yml配置更改</h1><p>在Hexo根目录下，<code>_config.yml</code>文件管理整个Hexo的配置设置。其中要开启<code>post_asset_folder</code>，即：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>更改完成后，每新生成一片文章，就会在同级目录下生成一个名字相同的相对应的文件夹。图片存在该文件夹下即可。</p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>由于原生Hexo资源文件夹在生成真正博客时地址转换有问题，需要安装插件进行修正。执行如下命令安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><p>当安装完成后就可以在写Markdown时很容易的使用资源文件夹下的图片了。</p><h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><p>在插入图片时只要使用如下Markdown语法即可<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名字/图片名字.后缀)</span><br></pre></td></tr></table></figure></p><p>不知道我是不是因为在<code>_config.yml</code>中开启了<code>relative_link</code>，我采用如下方式插入图片：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](图片名字.后缀)</span><br></pre></td></tr></table></figure></p><p>这点以后再探究好了喵～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在用Hexo搭建博客时有时需要插入图片，但是原生Hexo对图片管理的支持不是很好。此篇博客记录利用插件和Hexo的配置解决这个问题。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://lrscy.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中MathJax的用法</title>
    <link href="https://lrscy.github.io/2018/01/26/Markdown-MathJax-Usage/"/>
    <id>https://lrscy.github.io/2018/01/26/Markdown-MathJax-Usage/</id>
    <published>2018-01-26T14:25:33.000Z</published>
    <updated>2018-02-03T04:25:52.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Markdown和MathJax在一些语法上有交集，在此记录下两者有冲突的地方，作为今后的提醒。</p><h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>在Markdwon中，下划线代表斜体，例如：<code>_a_</code>的效果既是<em>a</em>。在MathJax中，下划线代表下标，例如：`$a\_2$’的效果既是$a_2$。</p><p>在Markdown解析过程中，可能会出现错误解析MathJax下划线的事情。因此在MathJax公式中要将<code>_</code>替换成<code>\_</code>，将下划线转义成真正的下划线符号。</p><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>在MathJax中，<code>\\</code>代表换行。在Markdown中，<code>\\</code>代表将转义字符<code>\</code>转义成真正的<code>\</code>字符，因此写<code>\\</code>后被解析出来时只有一个<code>\</code>，因此无法达成换行效果。因此在写换行时连续输入三个<code>\</code>即<code>\\\</code>即可达成换行要求。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">r\_t &amp;= \sigma(W\_rx\_t + Urh\_&#123;t-1&#125; + b\_r) \\\</span><br><span class="line">u\_t &amp;= \sigma(W\_ux\_t + r\_t \odot (U\_uh\_&#123;t-1&#125;) + b\_u) \\\</span><br><span class="line">h\_t &amp;= u\_t \odot h\_&#123;t-1&#125; + (1-u\_t) \odot \tanh(Wx\_t + r\_t \odot (U\_uh\_&#123;t-1&#125;) + b)</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><p>$$<br>\begin{align}<br>r_t &amp;= \sigma(W_rx_t + Urh_{t-1} + b_r) \\<br>u_t &amp;= \sigma(W_ux_t + r_t \odot (U_uh_{t-1}) + b_u) \\<br>h_t &amp;= u_t \odot h_{t-1} + (1-u_t) \odot \tanh(Wx_t + r_t \odot (U_uh_{t-1}) + b)<br>\end{align}<br>$$</p><p>目前只踩到了这些坑，今后再有新坑再往后填入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Markdown和MathJax在一些语法上有交集，在此记录下两者有冲突的地方，作为今后的提醒。&lt;/p&gt;
&lt;h1 id=&quot;下划线&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Usage" scheme="https://lrscy.github.io/categories/Usage/"/>
    
    
      <category term="Markdown" scheme="https://lrscy.github.io/tags/Markdown/"/>
    
      <category term="MathJax" scheme="https://lrscy.github.io/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下从零起步搭建配置github.io博客——Hexo</title>
    <link href="https://lrscy.github.io/2017/11/10/Ubuntu-Github-io-config-Hexo/"/>
    <id>https://lrscy.github.io/2017/11/10/Ubuntu-Github-io-config-Hexo/</id>
    <published>2017-11-10T05:00:00.000Z</published>
    <updated>2018-05-30T15:06:57.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。</p><p>继上次用Jekyll搭建博客后，又忙了很多其他事情，接触到了Hexo。因此决定将博客从Jekyll换到Hexo。</p><p>本人是个前端小白，按照网上众多教程搭建时候依旧踩了很多坑，在此记录下来以便有相同问题的同学可以快速解决。</p><p>搭建Github io静态博客所需基础之基础的知识如下：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a></li><li><a href="https://github.com/" target="_blank" rel="noopener">Github</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown</a></li><li><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a></li></ul><p>本文是在Ubuntu 17.04环境下配置的，如果使用其他操作系统请自行查找对应命令或者解决方案。</p><p>以下代码区域，带有<code>$</code>打头的表示需要在控制台（终端或称命令行）下面执行（不包括<code>$</code>符号）。如果出现权限不足提示请在命令最前面加上<code>sudo</code>再执行。</p><p>本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！</p><p>我是基于Hexo模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。</p><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><h2 id="Git-Github-SSH配置"><a href="#Git-Github-SSH配置" class="headerlink" title="Git/Github/SSH配置"></a>Git/Github/SSH配置</h2><p>详见我的博客「<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>」。</p><h2 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h2><p>安装Hexo前需要安装Node.js，本人安装的是Node.js 8。</p><p>对于Ubuntu系列系统，执行以下两个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">$ sudo apt install -y nodejs</span><br></pre></td></tr></table></figure></p><p>如果系统中没有安装<code>curl</code>，执行下述命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install curl</span><br></pre></td></tr></table></figure></p><p>安装完成后需要检查下<code>node</code>和<code>npm</code>的版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure></p><p>分别显示出版本号就算安装完成了～<br>本站搭建时<code>node</code>版本为<code>v8.9.1</code>，<code>npm</code>版本为<code>5.5.1</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">Node.js官网</a>。</p><h1 id="Hexo本地建站"><a href="#Hexo本地建站" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>Hexo安装非常简单，上述环境搭建好后只需执行以下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>本站搭建时Hexo的版本是3.4.0。</p><h2 id="Hexo本地建站-1"><a href="#Hexo本地建站-1" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h2><p>首先通过终端进入希望建站的文件夹内（例如<code>~/Hexo</code>），执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p><p>该命令要求建站文件夹是全空的文件夹。如果之前在该文件夹内建立了git等文件（夹），请先移出文件夹，建站完成后再移回来。</p><p>下述命令会在该文件夹下建立所有需要的文件。接下来安装依赖包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>至此，Hexo本地博客已经搭建完成。对，你没看错～</p><p>然后执行以下命令来浏览本地站点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><ul><li><code>hexo generate</code>是用来编译生成站点，每次对站点内容编辑后都要进行该项操作。可以简化为<code>hexo g</code>。</li><li><code>hexo server</code>是用来启动本地站点，执行后即可在浏览器中输入localhost:4000查看。可以简化为<code>hexo s</code>。</li></ul><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h1 id="Github-io部署博客"><a href="#Github-io部署博客" class="headerlink" title="Github io部署博客"></a>Github io部署博客</h1><h2 id="config-yml参数设置"><a href="#config-yml参数设置" class="headerlink" title="_config.yml参数设置"></a>_config.yml参数设置</h2><p>部署配置在_config.yml文件的末尾，默认样子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type:</span><br><span class="line">repo:</span><br></pre></td></tr></table></figure></p><p>修改后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: http://github.com/xxx/xxx.github.io.git(xxx是Github账户名称)</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p><ul><li>由于是部署到Github中，所以<code>type</code>是<code>git</code>。</li><li><code>repo</code>是指Github对应仓库的SSH地址。点击该仓库页面右侧绿色download，里面的地址就是<code>SSH</code>地址。</li><li><code>branch</code>是指上传到Github的哪个分支，如果没特殊需求选择<code>master</code>就可以。特殊需求请自行填写上传哪个branch。</li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>为了部署到Github上，需要安装hexo-deployer-git插件，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h2 id="最终部署"><a href="#最终部署" class="headerlink" title="最终部署"></a>最终部署</h2><p>最终部署需要输入以下两个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><ul><li><code>hexo generate</code>同上。</li><li><code>hexo deploy</code>将hexo部署到Github io上。可以简化为<code>hexo d</code>。</li></ul><p>上传后需要等待几分钟，然后就可以在浏览器中输入<code>xxx.github.io</code>来欣赏了喵～</p><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Hexo 部署</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。&lt;/p&gt;
&lt;p&gt;继上次用Jekyll搭
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Github.io" scheme="https://lrscy.github.io/tags/Github-io/"/>
    
  </entry>
  
</feed>
